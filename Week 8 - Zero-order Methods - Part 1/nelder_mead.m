function [xbest, fbest, history] = nelder_mead_simplex(f, x0, options)
% NELDER_MEAD  Nelder-Mead simplex optimization (from scratch).
%   This is 100% AI-generated by ChatGPT using the following prompts:
%   "Can you code Nelder-Mead simplex from scratch in MATLAB?
%   Use the Rosenbrock function as a test bed."
%   "Can you modify the second part of the code to visualize 
%   the simplex using fill function at every iteration?"
%
%   [xbest, fbest, history] = nelder_mead_simplex(f, x0, options)
%
% Inputs:
%   f       - function handle, f(x) where x is column vector
%   x0      - starting column vector (n x 1)
%   options - struct (optional) with fields:
%       maxIter (default 500)
%       maxEvals (default 2000)
%       tolFun (default 1e-8)
%       tolX (default 1e-6)
%       alpha (reflection, default 1)
%       gamma (expansion, default 2)
%       rho   (contraction, default 0.5)
%       sigma (shrink, default 0.5)
%       initScale (default 0.05) - relative size for initial simplex
%
% Outputs:
%   xbest   - estimated minimizer
%   fbest   - function value at xbest
%   history - struct with fields:
%             iter, funcEvals, xbest_history (n x m), 
%             fbest_history (1 x m), simplex_history (cell array)

% --- defaults ---
if nargin < 3, options = struct(); end
setopt = @(name,val) (iffield(options,name,val));
maxIter = setopt('maxIter',500);
maxEvals = setopt('maxEvals',2000);
tolFun = setopt('tolFun',1e-8);
tolX = setopt('tolX',1e-6);
alpha = setopt('alpha',1);
gamma = setopt('gamma',2);
rho   = setopt('rho',0.5);
sigma = setopt('sigma',0.5);
initScale = setopt('initScale',0.05);

% helper: pick option or default
    function v = iffield(s,k,d)
        if isfield(s,k), v = s.(k); 
        else, v = d; end
    end

x0 = x0(:);
n = numel(x0);

% Build initial simplex: n+1 vertices, columns of X
X = zeros(n, n+1);
X(:,1) = x0;
scale = initScale*(1 + abs(x0));
for i = 1:n
    ei = zeros(n,1); ei(i) = 1;
    X(:,i+1) = x0 + scale(i)*ei;
end

% Evaluate function at simplex points
fvals = zeros(1,n+1);
for j=1:n+1
    fvals(j) = f(X(:,j));
end
funcEvals = n+1;

% history
xbest_history = x0;
fbest_history = min(fvals);
simplex_history = {}; 

iter = 0;

% main loop
while true
    % sort simplex by function values ascending
    [fvals, idx] = sort(fvals);
    X = X(:, idx);
    
    simplex_history{end+1} = X; %#ok

    xbest = X(:,1); fbest = fvals(1);
    xworst = X(:,end); fworst = fvals(end);
    xsecond = X(:,end-1); fsecond = fvals(end-1); %#ok
    
    % record
    iter = iter + 1;
    xbest_history(:,end+1) = xbest; %#ok
    fbest_history(end+1) = fbest; %#ok
    
    % stopping checks
    if iter >= maxIter, break; end
    if funcEvals >= maxEvals, break; end
    if std(fvals) < tolFun, break; end
    maxdist = max( sqrt(sum((X(:,2:end) - X(:,1)).^2,1)) );
    if maxdist < tolX, break; end
    
    % centroid of all but worst
    xc = mean(X(:,1:end-1), 2);
    
    % reflection
    xr = xc + alpha*(xc - xworst);
    fr = f(xr); funcEvals = funcEvals + 1;
    
    if fr < fbest
        % expansion
        xe = xc + gamma*(xr - xc);
        fe = f(xe); funcEvals = funcEvals + 1;
        if fe < fr
            X(:,end) = xe; fvals(end) = fe;
        else
            X(:,end) = xr; fvals(end) = fr;
        end
        
    elseif fr < fsecond
        % Accept reflection
        X(:,end) = xr; fvals(end) = fr;
        
    else
        % contraction
        if fr < fworst
            % outside contraction
            xoc = xc + rho*(xr - xc);
            foc = f(xoc); funcEvals = funcEvals + 1;
            if foc <= fr
                X(:,end) = xoc; fvals(end) = foc;
            else
                % shrink
                for j = 2:n+1
                    X(:,j) = X(:,1) + sigma*(X(:,j) - X(:,1));
                    fvals(j) = f(X(:,j));
                    funcEvals = funcEvals + 1;
                end
            end
        else
            % inside contraction
            xic = xc + rho*(xworst - xc); % same as xc - rho*(xc - xworst)
            fic = f(xic); funcEvals = funcEvals + 1;
            if fic < fworst
                X(:,end) = xic; fvals(end) = fic;
            else
                % shrink
                for j = 2:n+1
                    X(:,j) = X(:,1) + sigma*(X(:,j) - X(:,1));
                    fvals(j) = f(X(:,j));
                    funcEvals = funcEvals + 1;
                end
            end
        end
    end
end

% Final sort and outputs
[fvals, idx] = sort(fvals);
X = X(:, idx);
xbest = X(:,1); fbest = fvals(1);

history.iter = iter;
history.funcEvals = funcEvals;
history.xbest_history = xbest_history;
history.fbest_history = fbest_history;
history.simplex_history = simplex_history;

end

% test_rosenbrock_nm.m
clear; close all; clc;

% Rosenbrock function (2D)
rosen = @(x) 100*(x(2)-x(1).^2).^2 + (1-x(1)).^2;

x0 = [-1.2; 1.0];
opts = struct('maxIter',200, 'initScale',0.2);

[xbest, fbest, hist] = nelder_mead_simplex(rosen, x0, opts);

fprintf('Result: x = [%g, %g], f = %g\n', xbest(1), xbest(2), fbest);

% Contour background
[xg, yg] = meshgrid(linspace(-2,2,200), linspace(-1,3,200));
zg = 100*(yg - xg.^2).^2 + (1 - xg).^2;

figure;
contourf(xg, yg, zg, 30, 'FaceAlpha', 0.6); hold on;
plot(1,1,'r*','MarkerSize',12,'LineWidth',1.5); % true minimizer
colormap("parula"); xlabel('x1'); ylabel('x2');
title('Nelderâ€“Mead Simplex Evolution on Rosenbrock');
axis tight; grid on; set(gcf, 'Color', 'w');

% Animate simplex
for k = 1:length(hist.simplex_history)
    Xk = hist.simplex_history{k};   % simplex vertices (2 x 3 for 2D)
    % close the polygon
    poly = [Xk, Xk(:,1)];
    % plot filled simplex with transparency
    hfill = fill(poly(1,:), poly(2,:), 'g', ...
        'FaceAlpha',0.8, 'EdgeColor','k');
    plot(Xk(1,:), Xk(2,:),'ko','MarkerSize',3, ...
        'MarkerFaceColor','k'); % vertices
    pause(0.1);  % adjust for speed
    if k < length(hist.simplex_history)
        delete(hfill); % remove previous simplex before next draw
    end
end
